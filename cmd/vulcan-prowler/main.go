/*
Copyright 2020 Adevinta
*/

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/arn"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/iam"
	"github.com/aws/aws-sdk-go/service/sts"

	check "github.com/adevinta/vulcan-check-sdk"
	"github.com/adevinta/vulcan-check-sdk/helpers"
	checkstate "github.com/adevinta/vulcan-check-sdk/state"
	report "github.com/adevinta/vulcan-report"
)

const (
	// defaultAPIRegion defines the default AWS region to use when querying AWS
	// services API endpoints.
	defaultAPIRegion       = `eu-west-1`
	defaultSessionDuration = 3600 // 1 hour.

	envEndpoint = `VULCAN_ASSUME_ROLE_ENDPOINT`
	envRole     = `ROLE_NAME`

	envKeyID     = `AWS_ACCESS_KEY_ID`
	envKeySecret = `AWS_SECRET_ACCESS_KEY`
	envToken     = `AWS_SESSION_TOKEN`
)

var (
	checkName = "vulcan-prowler"
	logger    = check.NewCheckLog(checkName)

	defaultGroups = []string{
		"cis_2.0_aws",
	}

	// CISCompliance is the vulnerability generated by the check when it does
	// not receive any security level and the account has failed controls.
	CISCompliance = report.Vulnerability{
		Summary: "Compliance With CIS AWS Foundations Benchmark (BETA)",
		Description: `<p>
			The check did not receive the security classification
			of the AWS account so the benchmark has been executed against the
			CIS Level 2.
			The CIS AWS Foundations Benchmark provides prescriptive
			guidance for configuring security options for a subset of Amazon Web
			Services with an emphasis on foundational, testable, and architecture
			agnostic settings. The services included in the scope are: IAM, Config,
			CloudTrail, CloudWatch, SNS, S3 and VPC (Default).
		</p>
		<p>
			Recommendations are provided in order to comply with all the controls required
			by the CIS Level 2.
		</p>
		<p>
			Check the Details and Resources sections to know the compliance status
			and more details.
		</p>`,
		Labels: []string{"compliance", "cis", "aws"},
		References: []string{
			"https://d0.awsstatic.com/whitepapers/compliance/AWS_CIS_Foundations_Benchmark.pdf",
			"https://github.com/prowler-cloud/prowler",
			"https://www.cisecurity.org/benchmark/amazon_web_services/",
		},
		Fingerprint: helpers.ComputeFingerprint(),
		Score:       report.SeverityThresholdMedium,
	}

	// CISLevel1Compliance is the vulnerability generated by the check when it
	// receives a security level of 1 or less and the account has failed
	// controls.
	CISLevel1Compliance = report.Vulnerability{
		Summary: "Compliance With CIS Level 1 AWS Foundations Benchmark (BETA)",
		Description: `<p>
			This account has been checked for compliance with the CIS Level 1 according
			to its security classification. You can check the security classification of the account in
			the details section.
			</p>
			<p>
			The CIS AWS Foundations Benchmark provides prescriptive
			guidance for configuring security options for a subset of Amazon Web
			Services with an emphasis on foundational, testable, and architecture
			agnostic settings. The services included in the scope are: IAM, Config,
			CloudTrail, CloudWatch, SNS, S3 and VPC (Default).
		</p>
		<p>
			Recommendations are provided in order to comply with all the controls required
			by the CIS Level 1.
		</p>
		<p>
			Check the Details and Resources sections to know the compliance status
			and more details.
		</p>`,
		Labels: []string{"compliance", "cis", "aws"},
		References: []string{
			"https://d0.awsstatic.com/whitepapers/compliance/AWS_CIS_Foundations_Benchmark.pdf",
			"https://github.com/prowler-cloud/prowler",
			"https://www.cisecurity.org/benchmark/amazon_web_services/",
		},
		Fingerprint: helpers.ComputeFingerprint(),
		Score:       report.SeverityThresholdMedium,
	}

	// CISLevel2Compliance is the vulnerability generated by the check when it
	// receives a security level of 2 or more and the account has failed
	// controls.
	CISLevel2Compliance = report.Vulnerability{
		Summary: "Compliance With CIS Level 2 AWS Foundations Benchmark (BETA)",
		Description: `<p>
			This account has been checked for compliance with the CIS Level 2 according
			to its security classification. You can check the security classification
			of the account in the details section.
			</p>
			<p>
			The CIS AWS Foundations Benchmark provides prescriptive
			guidance for configuring security options for a subset of Amazon Web
			Services with an emphasis on foundational, testable, and architecture
			agnostic settings. The services included in the scope are: IAM, Config,
			CloudTrail, CloudWatch, SNS, S3 and VPC (Default).
		</p>
		<p>
			Recommendations are provided in order to comply with all the controls required
			by the CIS Level 2.
		</p>
		<p>
			Check the Details and Resources sections to know the compliance status
			and more details.
		</p>`,
		Labels: []string{"compliance", "cis", "aws"},
		References: []string{
			"https://d0.awsstatic.com/whitepapers/compliance/AWS_CIS_Foundations_Benchmark.pdf",
			"https://github.com/prowler-cloud/prowler",
			"https://www.cisecurity.org/benchmark/amazon_web_services/",
		},
		Fingerprint: helpers.ComputeFingerprint(),
		Score:       report.SeverityThresholdMedium,
	}

	// CISComplianceInfo is a vulnerability that is always generated by the
	// check. It contains the not scored and informational controls related to
	// the account.
	CISComplianceInfo = report.Vulnerability{
		Summary: "Information About CIS AWS Foundations Benchmark (BETA)",
		Description: `<p>
				Information gathered by executing the CIS benchmark on the account.
		</p>
			`,
		Labels: []string{"compliance", "cis", "aws"},
		References: []string{
			"https://d0.awsstatic.com/whitepapers/compliance/AWS_CIS_Foundations_Benchmark.pdf",
			"https://github.com/prowler-cloud/prowler",
			"https://www.cisecurity.org/benchmark/amazon_web_services/",
		},
		Fingerprint: helpers.ComputeFingerprint(),
		Score:       report.SeverityThresholdNone,
	}
)

// TODO: Groups no longer exists now allows compliance (see prowler --list-compliance).
// TODO: Decide if we want to allow only CIS or adapt to other compliance/s.
type options struct {
	Region          string   `json:"region"`
	Groups          []string `json:"groups"`
	SessionDuration int      `json:"session_duration"` // In secs.
	SecurityLevel   *byte    `json:"security_level"`   // TODO: This is related only to CIS
}

func buildOptions(optJSON string) (options, error) {
	var opts options
	if optJSON != "" {
		if err := json.Unmarshal([]byte(optJSON), &opts); err != nil {
			return opts, err
		}
	}
	if opts.Groups == nil {
		opts.Groups = defaultGroups
	}
	if opts.SessionDuration == 0 {
		opts.SessionDuration = defaultSessionDuration
	}

	return opts, nil
}

func main() {
	run := func(ctx context.Context, target, assetType, optJSON string, state checkstate.State) error {
		if target == "" {
			return errors.New("check target missing")
		}
		parsedARN, err := arn.Parse(target)
		if err != nil {
			return err
		}

		opts, err := buildOptions(optJSON)
		if err != nil {
			return err
		}

		endpoint := os.Getenv(envEndpoint)
		accountId := ""
		if endpoint != "" {
			role := os.Getenv(envRole)

			logger.Infof("using endpoint '%s' and role '%s'", endpoint, role)

			isReachable, err := helpers.IsReachable(target, assetType,
				helpers.NewAWSCreds(endpoint, role))
			if err != nil {
				logger.Warnf("Can not check asset reachability: %v", err)
			}
			if !isReachable {
				return checkstate.ErrAssetUnreachable
			}

			if err := loadCredentials(endpoint, parsedARN.AccountID, role, opts.SessionDuration); err != nil {
				return fmt.Errorf("can not get credentials for the role '%s' from the endpoint '%s': %w", endpoint, role, err)
			}
		}
		logger.Infof("%s env var is empty - trying with provided credentials", envEndpoint)
		accountId, err = accountInfo(credentials.NewEnvCredentials())
		if err != nil {
			return fmt.Errorf("unable to get account info using provided credentials: %w", err)
		}
		if !strings.Contains(target, accountId) {
			return fmt.Errorf("provided credentials account mismatch %s vs %s", target, accountId)
		}

		alias, err := accountAlias(credentials.NewEnvCredentials())
		if err != nil {
			logger.Errorf("can not retrieve account alias: %v", err)
			alias = accountId
		} else {
			logger.Infof("account alias: '%s'", alias)
		}
		groups, err := groupsFromOpts(opts)
		if err != nil {
			return err
		}
		r, err := runProwler(ctx, opts.Region, groups)
		if err != nil {
			return err
		}

		comp, err := loadCompliance(groups[0])
		if err != nil {
			return err
		}

		var v report.Vulnerability
		if opts.SecurityLevel == nil {
			v = CISCompliance

		} else if *opts.SecurityLevel == 0 || *opts.SecurityLevel == 1 {
			v = CISLevel1Compliance
		} else {
			v = CISLevel2Compliance
		}
		fv, err := fillCISLevelVuln(&v, r, alias, opts.SecurityLevel, comp)
		if err != nil {
			return err
		}
		infov, err := buildCISInfoVuln(r, alias, opts.SecurityLevel, comp)
		if err != nil {
			return err
		}
		// if fv == nil it means there were no failed checks so there is no
		// vuln.
		if fv != nil {
			state.AddVulnerabilities(*fv)
		}
		state.AddVulnerabilities(infov)

		return nil
	}

	c := check.NewCheckFromHandler(checkName, run)
	c.RunAndServe()
}

func groupsFromOpts(opts options) ([]string, error) {
	// If the security level is specified then it defines the group to use.
	if opts.SecurityLevel == nil {
		return opts.Groups, nil
	}
	level := *opts.SecurityLevel
	if level > 2 {
		return nil, errors.New("invalid security level value")
	}

	if level == 0 || level == 1 {
		return []string{"cislevel1"}, nil
	}
	return []string{"cislevel2"}, nil

}

func buildCISInfoVuln(r *prowlerReport, alias string, slevel *byte, comp *compliance) (report.Vulnerability, error) {
	v := CISComplianceInfo
	var info []prowlerFinding
	infoTable := report.ResourcesGroup{
		Name: "Info + Not Scored Controls",
		Header: []string{
			"Control",
			"Description",
			"Region",
			"Message",
		},
	}
	for _, e := range *r {
		switch e.Status {
		case "Info":
			info = append(info, e)
			row := map[string]string{
				"Control":     e.CheckID,
				"Description": e.CheckTitle,
				"Region":      e.Region,
				"Message":     e.Description,
			}
			infoTable.Rows = append(infoTable.Rows, row)
		}
	}
	v.Resources = append(v.Resources, infoTable)

	v.Details = fmt.Sprintf("Account: %s\n", alias)
	if slevel != nil {
		v.Details += fmt.Sprintf("Security Level: %d\n", *slevel)
	}
	v.Details += "\n"
	v.Details += fmt.Sprintf("Info + Not Scored Controls: %d\n", len(info))

	return v, nil
}

func fillCISLevelVuln(v *report.Vulnerability, r *prowlerReport, alias string, slevel *byte, comp *compliance) (*report.Vulnerability, error) {
	type controlRow struct {
		row     map[string]string
		control string
		score   float32
	}
	var (
		total  int
		rows   []controlRow
		failed []prowlerFinding
	)
	fcTable := report.ResourcesGroup{
		Name: "Failed Controls",
		Header: []string{
			"Control",
			"Level",
			"CheckId",
			"Description",
			"CIS Severity",
			"Region",
			"Message",
			"References",
		},
	}

	for _, e := range *r {
		switch e.Status {
		case "FAIL":
			failed = append(failed, e)
			compName := fmt.Sprintf("%s-%s", comp.Framework, comp.Version) // i.e CIS-2.0
			cis, ok := e.Compliance[compName]
			var req requirement
			if ok && len(cis) > 0 {
				req = comp.getRequirement(cis[0])
			} else {
				logger.Errorf("Compliance %s not found in %v", compName, e.Compliance)
			}
			row := map[string]string{
				"Control":      req.ID,
				"Level":        req.getAttribute().Profile,
				"CheckId":      e.CheckID,
				"Description":  req.Description,
				"CIS Severity": e.Severity,
				"Region":       e.Region,
				"Message":      e.Description,
				// TODO: refine references. Now prints only the first, and doesn't checks if it exists
				// OMG, links separated by : but
				"References": fmt.Sprintf("<a href=\"%s\">Reference</a>", strings.Split(req.getAttribute().References, ":http")[0]),
			}
			c := controlRow{row, e.CheckID, severityToFloat(e.Severity)}
			rows = append(rows, c)
			fallthrough
		default:
			total++
		}
	}
	sort.Slice(rows, func(i, j int) bool {
		if rows[i].score == rows[j].score {
			return rows[i].control > rows[j].control
		}
		return rows[i].score > rows[j].score
	})
	for _, r := range rows {
		fcTable.Rows = append(fcTable.Rows, r.row)
	}
	v.Resources = append(v.Resources, fcTable)

	v.Details = fmt.Sprintf("Account: %s\n", alias)
	if slevel != nil {
		v.Details += fmt.Sprintf("Security Level: %d\n", *slevel)
	}
	v.Details += "\n"
	v.Details += fmt.Sprintf("Failed Controls: %d\n", len(failed))
	v.Details += fmt.Sprintf("Total Controls: %d\n", total)
	// This vulnerability only makes sense when there is, at least, one failed check.
	if len(failed) < 1 {
		return nil, nil
	}
	return v, nil
}

type assumeRoleResponse struct {
	AccessKey       string `json:"access_key"`
	SecretAccessKey string `json:"secret_access_key"`
	SessionToken    string `json:"session_token"`
}

func loadCredentials(url string, accountID, role string, sessionDuration int) error {
	m := map[string]interface{}{"account_id": accountID}
	if role != "" {
		m["role"] = role
	}
	if sessionDuration != 0 {
		m["duration"] = sessionDuration
	}
	jsonBody, _ := json.Marshal(m)
	req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonBody))
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	buf, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	var r assumeRoleResponse
	err = json.Unmarshal(buf, &r)
	if err != nil {
		logger.Errorf("can not decode response body '%s'", string(buf))
		return err
	}

	if err := os.Setenv(envKeyID, r.AccessKey); err != nil {
		return err
	}

	if err := os.Setenv(envKeySecret, r.SecretAccessKey); err != nil {
		return err
	}

	if err := os.Setenv(envToken, r.SessionToken); err != nil {
		return err
	}

	return nil
}

// accountAlias gets one of the current aliases for the account that the
// credentials passed belong to.
func accountAlias(creds *credentials.Credentials) (string, error) {
	sess, _ := session.NewSession(&aws.Config{Credentials: creds})
	svc := iam.New(sess)
	resp, err := svc.ListAccountAliases(&iam.ListAccountAliasesInput{})
	if err != nil {
		return "", err
	}
	if len(resp.AccountAliases) == 0 {
		logger.Warn("No aliases found for the account")
		return "", nil
	}
	a := resp.AccountAliases[0]
	if a == nil {
		return "", errors.New("unexpected nil getting aliases for aws account")
	}
	return *a, nil
}

// accountAlias gets one of the current aliases for the account that the
// credentials passed belong to.
func accountInfo(creds *credentials.Credentials) (string, error) {
	sess, _ := session.NewSession(&aws.Config{Credentials: creds})
	sts := sts.New(sess)
	ci, err := sts.GetCallerIdentity(nil)
	if err != nil {
		return "", err
	}
	return *ci.Account, nil
}

var severities = map[string]float32{
	"critical": 9.0,
	"high":     7.0,
	"medium":   4.0,
	"low":      0.1,
}

func severityToFloat(s string) float32 {
	v, ok := severities[s]
	if ok {
		return v
	}
	logger.Warnf("unknown severity %s", s)
	return 0.1
}

type compliance struct {
	Framework    string        `json:"Framework"`
	Version      string        `json:"Version"`
	Provider     string        `json:"Provider"`
	Description  string        `json:"Description"`
	Requirements []requirement `json:"requirements"`
}

type requirement struct {
	ID          string      `json:"Id"`
	Description string      `json:"Description"`
	Checks      []string    `json:"Checks"`
	Attributes  []attribute `json:"Attributes"`
}

type attribute struct {
	Section               string `json:"Section"`
	Profile               string `json:"Profile"`
	AssessmentStatus      string `json:"AssessmentStatus"`
	Description           string `json:"Description"`
	RationaleStatement    string `json:"RationaleStatement"`
	ImpactStatement       string `json:"ImpactStatement"`
	RemediationProcedure  string `json:"RemediationProcedure"`
	AuditProcedure        string `json:"AuditProcedure"`
	AdditionalInformation string `json:"AdditionalInformation"`
	References            string `json:"References"`
}

func loadCompliance(c string) (*compliance, error) {
	// TODO: Refactor hardcoded path
	content, err := os.ReadFile(fmt.Sprintf("/home/prowler/.local/lib/python3.11/site-packages/prowler/compliance/aws/%s.json", c))
	if err != nil {
		return nil, err
	}
	comp := compliance{}
	err = json.Unmarshal(content, &comp)
	if err != nil {
		return nil, err
	}
	return &comp, nil
}

func (comp *compliance) getRequirement(id string) requirement {
	for i, b := range comp.Requirements {
		if b.ID == id {
			return comp.Requirements[i]
		}
	}
	return requirement{}
}

func (req requirement) getAttribute() attribute {
	if len(req.Attributes) > 0 {
		return req.Attributes[0]
	}
	return attribute{}
}
